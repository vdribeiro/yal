
Avisos, Erros, Obrigações e Permissões da Análise Semantica:

Declarações Globais:

	Uma variável global não pode ser declarada igual a ela própria.
	Ex:
		a=a; <- erro
	
	Nas declarações globais uma variável pode ser declarada sem ser atribuido um valor ou tipo,
	ficando como integer por defeito, a não ser que o utilizador obrigue esta a ser um array com '[]'.
	A primeira atribuição define o tipo dessa variável.
	Ex: 
		a; <- por defeito é integer
		a=[10]; <- primeira atribuição, passa a ser um vector com 10 posições
		a=1; <- erro
		b[]; <- nao inicializado, mas obrigado a ser array
		b=1; <- erro
		b=[5]; <- ok
		
	Nas declarações globais se é feita uma atribuição a uma variável que já existe essa 
	so é aceite se for do tipo inteiro e for atribuido outro inteiro 
	senao é uma redeclarção de um vector.
	Ex:
		a=1; 
		b=[10];
		a=2; <- ok
		b=[5]; <- erro
		
Funções:
		
	O tipo de retorno da função é definido quando é feita a primeira atribuição à variável de retorno,
	a não ser que o utilizador obrigue o retorno a ser um array com '[]'.
	Ex:
		function a=funcao1() {
			a=1; <- primeira atribuição, variável integer
			a[]=3; <- erro
		}
		
		function b[]=funcao2() {
			b=1; <- erro
			b[2]=1; <- ok
		}
	
	Uma função com retorno tem de ter esse retorno especificado 
	pelo menos uma vez no corpo da função.
	Ex:
		function funcao1(a,b) {} <- ok, funcao void
		function c=funcao2(x,y) {} <- erro, nao se sabe o que 'c' retorna
		
	Uma função não pode ser declarada mais de uma vez.
	Ex:
		function f() {}
		function f() {} <- erro
		
	A lista de parâmetros de uma função não pode ter parâmetros repetidos 
	ou ter um parâmetro igual à variavel de retorno.
	Ex:
		function f1(a,a) {} <- erro
		function r=f2(a,r) {} <- erro
		function r=f3(a,b) {} <- ok
		
	Na chamada de uma função são testados se o numero e tipo 
	de argumentos dados é correcto,	assim como a sua existência, 
	tanto dos parametros como da própria função.
		
Ciclos, Condições e Operações Aritméticas:
		
	Nas expressões dos ciclos 'while' ou 'if' e nas operações aritméticas 
	só são aceites comparações ou operações entre inteiros ou 
	vectores e funcoes cujo resultado seja um inteiro.
	Ex:
		function f1[]=funcao1() {
			v=[10];
			f1=v;
		}
		
		function f2=funcao2(x,y,z[]) {
			soma = x+y; <-ok
			sub = y-z; <- erro
			mult = x*z[0]; <- ok
			div = y/funcao1(); <-erro
			
			f2=1;
		}
		
		function main() {
			a=2;
			b[0]=3;
		
			while (a<1) {...} <- ok
			if (a==funcao()) {...} <- ok
			while (a>b) {...} <- erro
			if (a!=b[0]) {...} <- ok
		}
		
		Numa expressão condicional não podemos ter a mesma variável com dois tipos possíveis 
		de retorno como está especificado nos exemplos de Yal.
		Ex:
			function m=f(a) 
			{
				if(a>10) {
					m=[a];
				} else {
					m=2;
				}
			}

Variáveis locais e atribuições:

	Um array não pode ser atribuido um inteiro.
	Um array para ser acedido pode estar declarado mas tem de ser inicializado.
	Um inteiro não pode:
		-ser atribuido a uma variavel tipo array.
		-ser atribuido a uma posição de um array não declarado.
		-ser atribuido a uma posição de um array declarado mas não inicializado.
		-passar dos limites maximo e minimos permitidos.
	Ex:
		a[];
		b=0;
		
		b=a; <- erro
		a[0] = b; <- erro
		
		a=b; <- erro
		b=a[1]; <- erro
		
		a=[10]; <- inicializamos
		b=a[1]; <- ok
		
		c=98765432101234567890; <- erro
		
	Num array o valor ou variável dada no tamanho tem de existir, 
	ser do tipo inteiro ou ser um array com um método que devolva um inteiro (p.ex 'size'),
	estar dentro dos limites e ser maior que zero.
	Ex:
		v=[10];
		a=1;
		
		b=[c]; <- erro
		b=[-2]; <- erro
		b=[v]; <- erro
		
		b=[v.size]; <- ok
		b=v; <- ok

	Numa atribuição, a variável esquerda não pode ser um método, ou seja,
	não pode ser atribuido um valor a um método de uma variável.
	Ex:
		a.size = 1 <- erro
		
	Todas as variáveis com ou sem indice são testadas, tanto para o indice 
	como para a variável, a validade. Ou seja, se existe e/ou se o tipo é compativel. 
	Se nao for diz qual a origem da variável que deu erro (parametro, retorno, local, global)
	Se uma variável contiver "." significa que esta a ser chamado um metodo
	(p/ex var.size) e portanto verifica se e array.
	
Modulos externos:

	É imprimido um aviso sempre que é chamado um método de um modulo externo,
	e é considerado que esse método devolve um inteiro.
	
	Por defeito, é considerado que todos os métodos da classe 'io' 
	devolvem um inteiro, com excepcao ao 'io.print' e 'io.println'
	que devolvem 'void'.
